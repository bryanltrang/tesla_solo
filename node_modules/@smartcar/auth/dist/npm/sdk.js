function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

;

(function (root, factory) {
  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
    module.exports = factory();
  } else {
    root.Smartcar = factory();
  }
})(this, function () {
  'use strict';
  /* eslint-env node */

  var Smartcar = /*#__PURE__*/function () {
    /**
     * @callback OnComplete
     * @param {?Error} error - something went wrong in Connect; this
     * normally indicates that the user denied access to your application or does not
     * have a connected vehicle
     * @param {String} code - the authorization code to be exchanged from a
     * backend sever for an access token
     * @param {Object} [state] - contains state if it was set on the initial
     * authorization request
     */

    /**
     * Initializes Smartcar class.
     *
     * @constructor
     * @param {Object} options - the SDK configuration object
     * @param {String} options.clientId - the application's client id
     * @param {String} options.redirectUri - the registered redirect uri of the
     * application
     * @param {String[]} [options.scope] - requested permission scopes
     * @param {OnComplete} [options.onComplete] - called on completion of Smartcar Connect
     * @param {Boolean} [options.testMode=false] - Deprecated, please use `mode` instead.
     * Launch Smartcar Connect in [test mode](https://smartcar.com/docs/guides/testing/).
     * @param {String} [options.mode='live'] - Determine what mode Smartcar Connect should be
     * launched in. Should be one of test, live or simulated.
    */
    function Smartcar(options) {
      var _this = this;

      _classCallCheck(this, Smartcar);

      // polyfill String.prototype.startsWith for IE11 support
      // istanbul ignore next
      if (!String.prototype.startsWith) {
        // eslint-disable-next-line no-extend-native
        String.prototype.startsWith = function (searchString, position) {
          position = position || 0;
          return this.substr(position, searchString.length) === searchString;
        };
      } // ensure options are well formed


      Smartcar._validateConstructorOptions(options);

      this.clientId = options.clientId;
      this.redirectUri = options.redirectUri;
      this.scope = options.scope;
      this.onComplete = options.onComplete;
      this.mode = 'live';

      if (options.hasOwnProperty('testMode')) {
        // eslint-disable-next-line no-console
        console.warn('The "testMode" parameter is deprecated, please use the "mode" parameter instead.');
        this.mode = options.testMode === true ? 'test' : 'live';
      } else if (options.hasOwnProperty('mode')) {
        this.mode = options.mode;
      }

      if (!['test', 'live', 'simulated'].includes(this.mode)) {
        throw new Error('The "mode" parameter MUST be one of the following: \'test\', \'live\', \'simulated\'');
      }

      this.responseType = 'code'; // identifier for matching message event and multiple Smartcar instances
      // it is a string composed of a timestamp and a 8-digit random number

      this.instanceId = new Date().getTime() + String(Math.random()).slice(2, 10); // handler

      this.messageHandler = function (event) {
        // bail if message from unexpected source
        if (!_this.redirectUri.startsWith(event.origin)) {
          return;
        }

        var message = event.data || {}; // bail if `message.name` is not `SmartcarAuthMessage`
        // this prevents attempting to handle messages intended for others

        if (message.name !== 'SmartcarAuthMessage') {
          return;
        } // bail if `state` is invalid


        var stateObject;

        try {
          stateObject = JSON.parse(window.atob(message.state));
        } catch (e) {
          return;
        }

        var _stateObject = stateObject,
            originalState = _stateObject.originalState,
            instanceId = _stateObject.instanceId; // bail if `instanceId` doesn't match

        if (instanceId !== _this.instanceId) {
          return;
        } // if onComplete not specified do nothing, assume developer is conveying
        // completion information from backend server receiving redirect to front
        // end (not using onComplete)


        if (_this.onComplete) {
          // if auth errored generate appropriate error else null
          var generateError = function generateError(error, description) {
            if (!error) {
              return null;
            }

            switch (error) {
              case 'access_denied':
                return new Smartcar.AccessDenied(description);

              case 'invalid_subscription':
                return new Smartcar.InvalidSubscription(description);

              case 'vehicle_incompatible':
                var params = event.data; // This field will always exist if vehicleInfo is returned

                if (!params.vin) {
                  return new Smartcar.VehicleIncompatible(description, null);
                } // These fields are required when vehicleInfo is returned


                var vehicleInfo = {
                  vin: params.vin,
                  make: params.make,
                  year: Number(params.year)
                }; // This field is optional

                if (params.model) {
                  vehicleInfo.model = params.model;
                }

                return new Smartcar.VehicleIncompatible(description, vehicleInfo);

              default:
                return new Error("Unexpected error: ".concat(error, " - ").concat(description));
            }
          };

          var err = generateError(message.error, message.errorDescription);
          /**
           * Call `onComplete` with parameters even if developer is not using
           * a Smartcar-hosted redirect. Regardless of if they are using a
           * Smartcar-hosted redirect they may still want `onComplete` to do
           * something with message.
           *
           * If empty onComplete is passed, parameters will be harmlessly ignored.
           *
           * If a developer chooses to pass an `onComplete` expecting these
           * parameters they must also handle populating the corresponding query
           * parameters in their redirect uri.
           */

          _this.onComplete(err, message.code, originalState);
        }
      }; // add handler for postMessage event on completion of Smartcar Connect


      window.addEventListener('message', this.messageHandler);
    }
    /**
     * Validate options passed to Smartcar constructor.
     *
     * See constructor documentation for enumeration of options properties.
     *
     * @private
     * @param {Object} options - the SDK configuration object
     */


    _createClass(Smartcar, [{
      key: "getAuthUrl",
      value:
      /**
       * Generates Smartcar OAuth URL.
       *
       * @param {Object} options - the link configuration object
       * @param {String} [options.state] - arbitrary state passed to redirect uri
       * @param {Boolean} [options.forcePrompt=false] - force permission approval
       * screen to show on every authentication, even if the user has previously
       * consented to the exact scope of permission
       * @param {String} [options.vehicleInfo.make] - `vehicleInfo` is an
       * object with an optional property `make`, which allows users to bypass the
       * car brand selection screen. For a complete list of supported brands, please
       * see our [API Reference](https://smartcar.com/docs/api#authorization)
       * documentation.
       * @param {Boolean|Object} [options.singleSelect] - An optional value that sets the
       * behavior of the grant dialog displayed to the user. If set to `true`,
       * `single_select` limits the user to selecting only one vehicle. If `single_select`
       * is passed in as an object with the property `vin`, Smartcar will only authorize
       * the vehicle with the specified VIN. See the
       * [API reference](https://smartcar.com/docs/api/#connect-match)
       * for more information.
       * @param {String[]} [options.flags] - An optional space-separated list of feature
       * flags that your application has early access to.
       *
       * @return {String} Connect URL to redirect user to.
       *
       * @example
       * https://connect.smartcar.com/oauth/authorize?
       * response_type=code
       * &client_id=8229df9f-91a0-4ff0-a1ae-a1f38ee24d07
       * &scope=read_odometer read_vehicle_info
       * &redirect_uri=https://example.com/home
       * &state=0facda3319
       * &make=TESLA
       * &single_select=true
       * &single_select_vin=5YJSA1E14FF101307
       * &flags=country:DE color:00819D
       */
      function getAuthUrl(options) {
        options = options || {};
        var link = '';
        link += 'https://connect.smartcar.com/oauth/authorize';
        link += "?response_type=".concat(this.responseType);
        link += "&client_id=".concat(this.clientId);
        link += "&redirect_uri=".concat(encodeURIComponent(this.redirectUri)); // map forcePrompt to approvalPrompt, two options: 'force' and 'auto'

        var forcePrompt = options.forcePrompt === true;
        link += "&approval_prompt=".concat(forcePrompt ? 'force' : 'auto'); // If scope is not specified, Smartcar will default to requesting all scopes
        // from the user

        if (this.scope) {
          link += "&scope=".concat(encodeURIComponent(this.scope.join(' ')));
        }

        link += "&mode=".concat(this.mode);

        if (options.singleSelect !== undefined && options.singleSelect !== null) {
          var singleSelectParamAdded = false;

          if (_typeof(options.singleSelect) === 'object') {
            var availableParams = ['vin'];

            for (var _i = 0, _availableParams = availableParams; _i < _availableParams.length; _i++) {
              var param = _availableParams[_i];

              if (param in options.singleSelect) {
                link += "&single_select_".concat(param, "=").concat(options.singleSelect[param]);
                singleSelectParamAdded = true;
              }
            }

            if (!singleSelectParamAdded) {
              link += '&single_select=false';
            } else {
              link += '&single_select=true';
            }
          } else {
            link += "&single_select=".concat(options.singleSelect === true);
          }
        } // augment state to track the corresponding instance


        var state = {
          instanceId: this.instanceId
        };

        if (options.state) {
          state.originalState = options.state;
        } // convert the augmented state to a base64 string


        link += "&state=".concat(window.btoa(JSON.stringify(state)));

        if (options.vehicleInfo) {
          var _availableParams2 = ['make'];

          for (var _i2 = 0, _availableParams3 = _availableParams2; _i2 < _availableParams3.length; _i2++) {
            var _param = _availableParams3[_i2];

            if (_param in options.vehicleInfo) {
              link += "&".concat(_param, "=").concat(encodeURIComponent(options.vehicleInfo[_param]));
            }
          }
        }

        if (options.flags) {
          link += "&flags=".concat(encodeURIComponent(options.flags.join(' ')));
        }

        return link;
      }
      /**
       * Launches Smartcar Connect in a new window.
       *
       * @param {Object} options - the link configuration object
       * @param {String} [options.state] - arbitrary state passed to redirect uri
       * @param {Boolean} [options.forcePrompt=false] - force permission approval
       * screen to show on every authentication, even if the user has previously
       * consented to the exact scope of permission
       * @param {String} [options.vehicleInfo.make] - `vehicleInfo` is an
       * object with an optional property `make`, which allows users to bypass the
       * car brand selection screen. For a complete list of supported makes, please
       * see our [API Reference](https://smartcar.com/docs/api#authorization)
       * documentation.
       * @param {Boolean|Object} [options.singleSelect] - An optional value that sets the
       * behavior of the grant dialog displayed to the user. If set to `true`,
       * `single_select` limits the user to selecting only one vehicle. If `single_select`
       * is passed in as an object with the property `vin`, Smartcar will only authorize
       * the vehicle with the specified VIN. See the
       * [API reference](https://smartcar.com/docs/api/#connect-match)
       * for more information.
       * @param {String[]} [options.flags] - An optional space-separated list of feature
       * flags that your application has early access to.
       * @param {WindowOptions} [options.windowOptions] - position and size settings for
       * the popup window
       */

    }, {
      key: "openDialog",
      value: function openDialog(options) {
        var windowOptions = Smartcar._getWindowOptions(options.windowOptions || {});

        var href = this.getAuthUrl(options);
        window.open(href, 'Connect your car', windowOptions);
      }
      /**
       * Adds an on-click event listener to the element with the provided id.
       *
       * On-click event calls openDialog when the specified element is clicked.
       *
       * @param {Object} options - clickHandler configuration object
       * @param {String} [options.id] - id of the element to add click handler to
       * @param {String} [options.selector] - css selector of the element(s) to add click handler to
       * @param {String} [options.state] - arbitrary state passed to redirect uri
       * @param {Boolean} [options.forcePrompt=false] - force permission approval
       * screen to show on every authentication, even if the user has previously
       * consented to the exact scope of permission
       * @param {String} [options.vehicleInfo.make] - `vehicleInfo` is an
       * object with an optional property `make`, which allows users to bypass the
       * car brand selection screen. For a complete list of supported makes, please
       * see our [API Reference](https://smartcar.com/docs/api#authorization)
       * documentation.
       * @param {Boolean|Object} [options.singleSelect] - An optional value that sets the
       * behavior of the grant dialog displayed to the user. If set to `true`,
       * `single_select` limits the user to selecting only one vehicle. If `single_select`
       * is passed in as an object with the property `vin`, Smartcar will only authorize
       * the vehicle with the specified VIN. See the
       * [API reference](https://smartcar.com/docs/api/#connect-match)
       * for more information.
       * @param {String[]} [options.flags] - An optional space-separated list of feature
       * flags that your application has early access to.
       * @param {WindowOptions} [options.windowOptions] - position and size settings for
       * the popup window
       */

    }, {
      key: "addClickHandler",
      value: function addClickHandler(options) {
        var _this2 = this;

        var id = options.id,
            selector = options.selector; // check if id or selector option exists

        if (!id && !selector) {
          throw new Error('Could not add click handler: id or selector must be provided.');
        } // find all the DOM elements that match the id and selector


        var elements = [];

        if (id) {
          var element = document.getElementById(id);

          if (element) {
            elements.push(element);
          }
        }

        if (selector) {
          elements.push.apply(elements, _toConsumableArray(document.querySelectorAll(selector)));
        }

        if (!elements.length) {
          throw new Error("\n        Could not add click handler: element with '".concat(id || selector, "' was not found.\n      "));
        } // _elementToClickHandler stores all the element - clickHandler pairs under the same instance
        // because it is possible to call addClickHandler multiple times with different options


        if (!this._elementToClickHandler) {
          this._elementToClickHandler = new Map();
        }

        var clickHandler = function clickHandler() {
          _this2.openDialog(options); // this is equivalent to calling:
          // event.preventDefault();
          // event.stopPropogation();


          return false;
        };

        elements.forEach(function (element) {
          // register element - clickHandler pair
          _this2._elementToClickHandler.set(element, clickHandler); // register eventListener


          element.addEventListener('click', clickHandler);
        });
      }
      /**
       * Remove Smartcar's event listeners.
       *
       * 1. remove listener on the global window object:
       * The Smartcar SDK uses a global 'message' event listener to recieve the
       * authorization code from the pop-up dialog. Call this method to remove the
       * event listener from the global window.
       *
       * 2. remove click event listeners on DOM elements
       * The Smartcar SDK also provides an `addClickHandler` method to attach click
       * events to DOM elements. These event listeners will also be removed by calling
       * this `unmount` method.
       */

    }, {
      key: "unmount",
      value: function unmount() {
        window.removeEventListener('message', this.messageHandler);

        if (this._elementToClickHandler) {
          var _iterator = _createForOfIteratorHelper(this._elementToClickHandler.entries()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  element = _step$value[0],
                  clickHandler = _step$value[1];

              element.removeEventListener('click', clickHandler);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
    }], [{
      key: "_validateConstructorOptions",
      value: function _validateConstructorOptions(options) {
        if (!options.clientId) {
          throw new TypeError('A client ID option must be provided');
        }

        if (!options.redirectUri) {
          throw new TypeError('A redirect URI option must be provided');
        }

        if (options.redirectUri.startsWith('https://javascript-sdk.smartcar.com')) {
          // require onComplete method with at least two parameters (error & code)
          // when hosting on Smartcar CDN
          if (!options.onComplete || options.onComplete.length < 2) {
            throw new Error("When using Smartcar's CDN redirect an onComplete function with at" + ' least 2 parameters (error & code) is required to handle' + ' completion of Connect');
          }

          var usesOldUriScheme = /redirect-[0-9]+\.[0-9]+\.[0-9]+\?/.test(options.redirectUri);

          if (usesOldUriScheme) {
            // eslint-disable-next-line no-console
            console.warn("\nThe Smartcar redirect URI you're using is outdated! To update it, please see:\nhttps://smartcar.com/docs/guides/new-redirect-uri\n");
          }
        }
      }
      /**
       * Position and size settings for the popup window.
       *
       * @see Please reference the {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features|Window.open()#Window Features}
       * MDN article for more details
       *
       * @typedef {Object} WindowOptions
       * @property {String} [top]
       * @property {String} [left]
       * @property {String} [width]
       * @property {String} [height]
       */

      /**
       * Calculate popup window size and position based on current window settings.
       *
       * @private
       * @param {WindowOptions} options
       * @return {String} a string of window settings
       */

    }, {
      key: "_getWindowOptions",
      value: function _getWindowOptions(windowOptions) {
        Object.keys(windowOptions).forEach(function (option) {
          var numValue = parseFloat(windowOptions[option]);

          if (isNaN(numValue)) {
            windowOptions[option] = '';
          } else if (numValue < 100 && (option === 'width' || option === 'height')) {
            windowOptions[option] = '100';
          } else {
            windowOptions[option] = String(numValue);
          }
        }); // Sets default popup window size as percentage of screen size
        // Note that this only applies to desktop browsers

        var windowSettings = {
          width: window.screen.width * 0.3,
          height: window.screen.height * 0.75
        };
        var widthOffset = (window.outerWidth - windowSettings.width) / 2;
        var heightOffset = (window.outerHeight - windowSettings.height) / 8;
        var options = '';
        options += "top=".concat(windowOptions.top || window.screenY + heightOffset, ",");
        options += "left=".concat(windowOptions.left || window.screenX + widthOffset, ",");
        options += "width=".concat(windowOptions.width || windowSettings.width, ",");
        options += "height=".concat(windowOptions.height || windowSettings.height, ",");
        return options;
      }
    }]);

    return Smartcar;
  }();
  /**
   * Access denied error returned by Connect.
   *
   * @extends Error
   */


  Smartcar.AccessDenied = /*#__PURE__*/function (_Error) {
    _inherits(_class, _Error);

    var _super = _createSuper(_class);

    /**
     * @param {String} message - detailed error description
     */
    function _class(message) {
      var _this3;

      _classCallCheck(this, _class);

      _this3 = _super.call(this, message);
      _this3.name = 'AccessDenied';
      return _this3;
    }

    return _createClass(_class);
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * Vehicle incompatible error returned by Connect. Will optionally
   * have a vehicleInfo object if the user chooses to give permissions to provide
   * that information. See our [Connect documentation](https://smartcar.com/docs/api#smartcar-connect)
   * for more details.
   *
   * @extends Error
   */


  Smartcar.VehicleIncompatible = /*#__PURE__*/function (_Error2) {
    _inherits(_class2, _Error2);

    var _super2 = _createSuper(_class2);

    /**
     * @param {String} message - detailed error description
     * @param {?Object} vehicleInfo - If a vehicle is incompatible, the user has
     * the option to return vehicleInfo to the application.
     * @param {String} vehicleInfo.vin - returned if user gives permission.
     * @param {String} vehicleInfo.make - returned if user gives permission.
     * @param {Number} vehicleInfo.year - returned if user gives permission.
     * @param {String} [vehicleInfo.model] - optionally returned if user gives permission.
     */
    function _class2(message, vehicleInfo) {
      var _this4;

      _classCallCheck(this, _class2);

      _this4 = _super2.call(this, message);
      _this4.name = 'VehicleIncompatible';
      _this4.vehicleInfo = vehicleInfo;
      return _this4;
    }

    return _createClass(_class2);
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * Invalid subscription error returned by Connect.
   *
   * @extends Error
   */


  Smartcar.InvalidSubscription = /*#__PURE__*/function (_Error3) {
    _inherits(_class3, _Error3);

    var _super3 = _createSuper(_class3);

    /**
     * @param {String} message - detailed error description
     */
    function _class3(message) {
      var _this5;

      _classCallCheck(this, _class3);

      _this5 = _super3.call(this, message);
      _this5.name = 'InvalidSubscription';
      return _this5;
    }

    return _createClass(_class3);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  return Smartcar;
});